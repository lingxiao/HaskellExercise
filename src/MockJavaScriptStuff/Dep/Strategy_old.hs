{-# LANGUAGE ImpredicativeTypes #-} 
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------
-- | 
-- | Module : Mock Application that create typeclass in javascript
-- | Creator: Xiao Ling
-- | Created: November 2nd
-- | 
---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------

module Strategy (

	   Move
	 , Strat

) where 

import Control.Monad
import Control.Applicative
import Control.Monad.Reader
import Text.Show.Functions

import Data.Bifunctor
import Data.Dynamic
import Data.Monoid

import Core
import Coroutine

{-----------------------------------------------------------------------------
   Types
------------------------------------------------------------------------------}

-- * Primitives * -- 

type BinFunc a b c = a -> b -> c

-- * Class and Instance types

-- * need some information on Kind, where does it get stored? should you just shove it in here?
-- * does member Func need information on arity because symmetry?
type Class a      = (ClassName, Kind, [MemberFunc a]) 				-- * TODO: reform this into (,) TypeClass [MemberFunc a]
type MemberFunc a = (,) FnName  (Strat a)

type Instance     = (,) DataType [FuncImpl]
type FuncImpl     = (,) FnName Dynamic							-- * unwrapped : `(,) FnName (BinFunc a b c)`

-- * Program types

type ClassEnv a   = [Class a]
type InstEnv      = (,) ClassName [Instance]

type Move  a      = forall m. Monad m => CoroutineT (Intel a) (Intel a) (ReaderT InstEnv m) ()
type Strat a      = Move a 

-- * Intel is either A datatype some some type `a`, a list of `DataType` names,
-- * or some `Dynamic` value generated by upstream coroutine. Note `Dynamic` can only be some `BinFunc b c d`
data Intel a      = A a | D [DataType] | F Dynamic deriving (Show)
type FuzzyIntel a = Either Error (Intel a)

{-----------------------------------------------------------------------------
	Primitive Operations over Types
------------------------------------------------------------------------------}

-- * Constructors * --

-- * member function instance constructor
mem :: (Typeable a, Typeable b, Typeable c) => FnName -> BinFunc a b c -> FuncImpl
mem fn = (,) fn . toDyn

-- * constructor
toClass :: ClassName -> Kind -> [(FnName, Signature)] -> Class a
toClass cn n gs = undefined 
-- (,) cn $ (\(gn, s) -> (gn, fromSig s)) <$> gs where
-- fromSig = undefined

-- * construct an `Instance` where the `FuncImpl a b c` are wrapped in `Dynamic` constructor
toInst :: ClassName -> DataType -> [(FnName, Dynamic)] -> Instance
toInst _ dn = (,) dn

noIntel :: Intel a
noIntel = D mempty

-- * create an empty instance environemnt
env :: ClassName -> InstEnv
env = flip (,) mempty

-- * Accessors * --

askClass :: ClassEnv a -> ClassName -> Either String (Class a)
askClass env n = flip listToEither [ x | x@(cn,_,_) <- env, cn == n ] $ "Class " ++ n ++ " not in scope"

eqKind :: Class a -> Kind -> Bool
eqKind (_,k,_) = (==) k

putInst :: Instance -> InstEnv -> InstEnv
putInst i (cn,is) = (cn, is ++ [i])

askInst :: InstEnv -> DataType -> Either String Instance
askInst (cn,is) dn = listToEither msg [ i | i@(dn', _) <- is, dn' == dn ] 
	where msg = "Instance " ++ dn ++ " not found for class " ++ cn 

askFunc :: Instance -> FnName -> Either String Dynamic
askFunc (n,gs) fn = listToEither msg [ f | (fn', f) <- gs, fn' == fn ] 
	where msg = "Function " ++ fn ++ " not found instance " ++ n


{-----------------------------------------------------------------------------
	Program I a : Move && Strategy Formulation one
------------------------------------------------------------------------------}

{-
	where we left off:

	for sake of modularlity, there should be *NO* parameters passed into moves,
	there has to be some clever (?) sensible way to read parameter from the 
	environment

-}

-- * Move Constructors * --

-- * make these more terse with: http://stackoverflow.com/questions/10112733/haskell-simple-constructor-comparison-functionarry Holroyd

notIntel :: Char -> Move a 
notIntel = err . (++) "expected value constructor " . pure 

atA :: (Intel a -> FuzzyIntel a) -> Move a 
atA g = await >>= \t -> case t of 
	A d -> either err yield . g $ A d
	_   -> notIntel 'A'

atD :: (Intel a -> FuzzyIntel a) -> Move a 
atD g = await >>= \t -> case t of 
	D d -> either err yield . g $ D d
	_   -> notIntel 'D'

atF :: (Intel a -> FuzzyIntel a) -> Move a 
atF g = await >>= \t -> case t of 
	F f -> either err yield . g $ F f 
	_   -> notIntel 'F'


-- * Fundamental Moves * --

-- * cap the head of of a pipeline to prevent leaky awaits 
capH :: Move a
capH = source . pure $ noIntel

typed :: (a -> Either String DataType) -> a -> Move a
typed k x = atD $ \(D ds) -> bimap id (\d -> D $ ds ++ [d]) $ k x

sameType :: Move a 
sameType = atD $ \(D ds) -> if all (== head ds) ds then Right . D $ ds else Left $ "type error"

fndFunc :: FnName -> Move a
fndFunc fn 
	=   atD (\(D ds) -> if length ds == 0 then Left "No datatype provided" else Right . D . pure . head $ ds) 
	~> do
		D (d:_) <- await
		env     <- lift ask
		either err (either err (yield . F) . flip askFunc fn) $ env `askInst` d

satClosure :: (a -> Either String DataType) -> a -> Move a
satClosure k x = atA $ \(A y) -> case (k x, k y) of 
	(Right tx, Right ty) -> if tx == ty then Right . A $ y else Left $ "types " ++ tx ++ " " ++ " and " ++ ty ++ " does not match"
	_ 					 -> Left $ "no type information provided"


-- * an attemp at writing one eval that could be used in different ways

-- * consider master eval that lifts everything into some function \x. E
-- * where x is () for 'non-function' values
eval' :: (Typeable a, Typeable b, Typeable c, Typeable d) => a -> (b -> c) -> Move d
eval' x f = atF $ \(F g) -> case fromDynamic g of 
	Nothing -> Left "No implementation found"
	Just g' -> Right . A $ g' x f

-- * could this replace `eval` ? how would you force evaluation of second lambada?
eval'' :: (Typeable a, Typeable b, Typeable c) => a -> b -> Move c
eval'' x y = eval' x $ \() -> y 


-- * As long as some value `F g` is generated by a move here, the value wrapped by `Dynamic` has to be 
-- * a function of form `a -> b -> c`. 
eval :: (Typeable a, Typeable b, Typeable c) => a -> b -> Move c
eval x y = atF $ \(F g) -> case fromDynamic g of 
	Nothing -> Left "no function found"
	Just g' -> Right . A $ g' x y 


-- * Strategy * -- 

{-----------------------------------------------------------------------------
	Program I b : Move && Strategy Formulation two
------------------------------------------------------------------------------}

-- * is it possible for all params to go inside a list?
-- * you have to use some Dynamic wrap, and it looks like you're startig to abuse
-- * this pattern

-- * where does the function for reading variables fit ? in the operating environmemnt?
-- * there's the instance env where implementation of member functions are found, and operating environment where variables are found
-- type OpEnv   = (,) [Param] AccessF

-- * note the following can be factored out by writing combinator of form:
-- * (Env -> a -> Either String DataType) -> Move a
-- * so that domain logic is separate from interacting with env logic32\\\\

-- * how does the parser know which index to use?
-- * indexing seems very primitive and introduces errors
-- * making the env so complicated also seem primitive

{-

typed_ :: Typeable a => Int -> Move a 
typed_ i = do
	t   <- await
	env  <- lift askm
	let k  = accessF env
	let mx = param i env
	if mx == Nothing then err "..." else case t of 
		D ds -> either err yield $ bimap id (D . (++) ds) . k . fromJust $ x
		_    -> err "not value constructor D"


eval_ :: Typeable a => Move a 
eval_ = do 
	t   <- await
	env  <- lift get
	let xs = params env
	case t of 
		F g -> case fromDynamic g of 
			Nothing -> err "..."
			Just g' -> yield $ bindParam g' xs
-}


{-----------------------------------------------------------------------------
	Utils
------------------------------------------------------------------------------}

listToEither :: a -> [b] -> Either a b 
listToEither a m = case m of 
	[]   -> Left a
	x:xs -> Right x

maybeToEither :: a -> Maybe b -> Either a b 
maybeToEither a m = case m of 
	Nothing -> Left a 
	Just b  -> Right b







